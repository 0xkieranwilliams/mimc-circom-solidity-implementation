pragma circom 2.0.0;

template MiMC5() {
  signal input x; 
  signal input k; 
  signal output h;

  var nRounds = 10;

  var c[nRounds] = [
    0,
    81267508508943089542119141718816171702175751362421721808008409724587372567402,
    82549416809288341021702880577288618629374489033499052253782142246114419665341,
    109206284254671900743241533452377855708054610592542125593627602217146010682341,
    97047473353828477906743361674888655662363010779317563554348250689346499297972,
    20722874102262470813003450073921050537631911991474070577892306508679922985455,
    15868405948871687681468472844859228477017686626681393981606220840125262862832,
    113852166332449360953358404408849594476139010360220012333816529059971948242799,
    3313407124743833025119320838366173902545221821190252740799359315412938037078,
    103045447348244353507405560235128465894423923102745658092443851834739387598373
  ];

  signal lastOutput[nRounds + 1];
  signal base[nRounds];
  signal base2[nRounds];
  signal base4[nRounds];

  lastOutput[0] <== x;

  for (var i = 0; i < nRounds; i++){
    base[i] <== lastOutput[i] + k + c[i];
    base2[i] <== base[i] * base[i];
    base4[i] <== base2[i] * base2[i];

    lastOutput[i + 1] <== base4[i] * base[i];
  }
  h <== lastOutput[nRounds] + k;
}

component main = MiMC5();
